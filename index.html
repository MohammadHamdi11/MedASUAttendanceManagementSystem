<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>QR Code Scanner</title>
<!-- PWA Meta Tags -->
<meta name="theme-color" content="#24325f">
<meta name="description" content="A QR code scanner application">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="QR Scanner">
<!-- iOS icon links -->
<link rel="apple-touch-icon" href="icons/icon-152x152.png">
<!-- Manifest file link -->
<link rel="manifest" href="manifest.json">
<style>
:root {
--primary-color: #24325f;
--secondary-color: #951d1e;
--text-color: #000000;
--bg-color: #ffffff;
--card-bg: #ffffff;
--border-color: #3d3d3d;
}
* {
box-sizing: border-box;
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}
body {
margin: 0;
padding: 0;
background-color: var(--bg-color);
color: var(--text-color);
}
header {
background-color: var(--primary-color);
color: white;
text-align: center;
padding: 1rem;
position: sticky;
top: 0;
z-index: 100;
}
.container {
max-width: 1200px;
margin: 0 auto;
padding: 1rem;
}
.card {
background-color: var(--card-bg);
border-radius: 8px;
box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
padding: 1rem;
margin-bottom: 1rem;
}
.button {
background-color: var(--primary-color);
color: white;
border: none;
border-radius: 4px;
padding: 0.75rem 1rem;
cursor: pointer;
font-size: 1rem;
transition: background-color 0.3s;
}
.button:hover {
background-color: var(--secondary-color);
}
.button:disabled {
background-color: #cccccc;
cursor: not-allowed;
}
.button-secondary {
background-color: #f1f1f1;
color: var(--text-color);
border: 1px solid var(--border-color);
}
.button-secondary:hover {
background-color: #e1e1e1;
}
.tabs {
display: flex;
border-bottom: 1px solid var(--border-color);
margin-bottom: 1rem;
}
.tab {
padding: 0.75rem 1.5rem;
cursor: pointer;
border-bottom: 3px solid transparent;
}
.tab.active {
border-bottom: 3px solid var(--primary-color);
font-weight: bold;
}
.tab-content {
display: none;
}
.tab-content.active {
display: block;
}
#video {
width: 100%;
background-color: #000;
border-radius: 8px;
}
.scanner-container {
position: relative;
min-height: 300px;
}
.result-table {
width: 100%;
border-collapse: collapse;
margin-top: 1rem;
}
.result-table th, .result-table td {
border: 1px solid var(--border-color);
padding: 0.5rem;
text-align: left;
}
.result-table th {
background-color: #f1f1f1;
}
.modal {
display: none;
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.5);
z-index: 1000;
}
.modal-content {
background-color: var(--card-bg);
margin: 15% auto;
padding: 20px;
border-radius: 8px;
width: 80%;
max-width: 500px;
}
.close {
float: right;
cursor: pointer;
font-size: 1.5rem;
}
input[type="text"] {
width: 100%;
padding: 0.75rem;
margin: 0.5rem 0;
border: 1px solid var(--border-color);
border-radius: 4px;
}
.history-item {
cursor: pointer;
}
.history-item:hover {
background-color: #f5f5f5;
}
.session-details {
margin-top: 1rem;
}
.flex-between {
display: flex;
justify-content: space-between;
align-items: center;
flex-wrap: wrap;
}
.no-results {
text-align: center;
padding: 2rem;
color: #666;
}
.filter-controls {
margin-bottom: 1rem;
}
select {
padding: 0.5rem;
border: 1px solid var(--border-color);
border-radius: 4px;
}
@media (max-width: 768px) {
.button {
width: 100%;
margin-bottom: 0.5rem;
}
.flex-between {
flex-direction: column;
align-items: stretch;
}
.modal-content {
width: 95%;
margin: 10% auto;
}
}
</style>
</head>
<body>
<header>
<h1>QR Code Scanner</h1>
</header>
<div class="container">
<div class="tabs">
<div class="tab active" data-tab="scanner">Scanner</div>
<div class="tab" data-tab="history">History</div>
</div>
<div id="scanner" class="tab-content active">
<div class="card">
<h2>QR Code Scanner</h2>
<div class="flex-between">
<button id="startSessionBtn" class="button">Start Scanning Session</button>
<div id="sessionInfo" style="display: none;">
<p><strong>Location:</strong> <span id="currentLocation">-</span></p>
<p><strong>Started:</strong> <span id="currentDateTime">-</span></p>
</div>
</div>
<div class="scanner-container">
<div id="scanner-placeholder" style="text-align: center; padding: 2rem;">
<p>Click "Start Scanning Session" to begin scanning QR codes.</p>
</div>
<video id="video" style="display: none;"></video>
</div>
<div class="scan-results">
<h3>Scanned QR Codes</h3>
<p id="noScansMessage">No QR codes scanned yet.</p>
<table id="resultTable" class="result-table" style="display: none;">
<thead>
<tr>
<th>ID</th>
<th>Content</th>
<th>Time</th>
</tr>
</thead>
<tbody id="resultBody"></tbody>
</table>
</div>
</div>
</div>
<div id="history" class="tab-content">
<div class="card">
<h2>Scanning History</h2>
<div class="flex-between">
<div>
<button id="exportAllBtn" class="button">Export All History</button>
</div>
<div class="filter-controls">
<select id="sortBy">
<option value="date-desc">Date (Newest First)</option>
<option value="date-asc">Date (Oldest First)</option>
<option value="location">Location</option>
</select>
</div>
</div>
<div id="historyList">
<p class="no-results">No scanning sessions found.</p>
</div>
<div id="sessionDetails" class="session-details" style="display: none;">
<h3>Session Details</h3>
<div class="flex-between">
<div>
<p><strong>Location:</strong> <span id="detailLocation">-</span></p>
<p><strong>Date & Time:</strong> <span id="detailDateTime">-</span></p>
<p><strong>Scans:</strong> <span id="detailCount">-</span></p>
</div>
<div>
<button id="exportSessionBtn" class="button">Export Session</button>
<button id="closeDetailsBtn" class="button button-secondary">Close Details</button>
</div>
</div>
<table class="result-table">
<thead>
<tr>
<th>ID</th>
<th>Content</th>
<th>Time</th>
</tr>
</thead>
<tbody id="detailsBody"></tbody>
</table>
</div>
</div>
</div>
</div>
<!-- Modal for Starting Session -->
<div id="sessionModal" class="modal">
<div class="modal-content">
<span class="close">&times;</span>
<h2>Start New Scanning Session</h2>
<p>Enter a location for this scanning session:</p>
<input type="text" id="locationInput" placeholder="e.g., Warehouse A, Office Room 102">
<p>This will help you identify and organize your scans.</p>
<button id="confirmSessionBtn" class="button">Start Now</button>
</div>
</div>
<!-- Script for QR Code Scanning -->
<script src="jsQR.min.js"></script>
<!-- Script for Excel Export -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script>
// DOM Elements
const tabs = document.querySelectorAll('.tab');
const tabContents = document.querySelectorAll('.tab-content');
const startSessionBtn = document.getElementById('startSessionBtn');
const sessionModal = document.getElementById('sessionModal');
const closeModalBtn = document.querySelector('.close');
const confirmSessionBtn = document.getElementById('confirmSessionBtn');
const locationInput = document.getElementById('locationInput');
const currentLocation = document.getElementById('currentLocation');
const currentDateTime = document.getElementById('currentDateTime');
const sessionInfo = document.getElementById('sessionInfo');
const video = document.getElementById('video');
const scannerPlaceholder = document.getElementById('scanner-placeholder');
const resultTable = document.getElementById('resultTable');
const resultBody = document.getElementById('resultBody');
const noScansMessage = document.getElementById('noScansMessage');
const exportAllBtn = document.getElementById('exportAllBtn');
const historyList = document.getElementById('historyList');
const sessionDetails = document.getElementById('sessionDetails');
const detailLocation = document.getElementById('detailLocation');
const detailDateTime = document.getElementById('detailDateTime');
const detailCount = document.getElementById('detailCount');
const detailsBody = document.getElementById('detailsBody');
const exportSessionBtn = document.getElementById('exportSessionBtn');
const closeDetailsBtn = document.getElementById('closeDetailsBtn');
const sortBy = document.getElementById('sortBy');

// Application State
let activeSession = null;
let canvasElement = document.createElement('canvas');
let canvas = canvasElement.getContext('2d');
let scanning = false;
let videoStream = null;
let sessions = [];
let activeSessionId = null;
let lastScannedCodes = new Set(); // For avoiding duplicate scans in quick succession
let jsQRLoaded = false;
let autoSaveInterval = null;

// Constants for auto-save functionality
const AUTO_SAVE_DELAY = 3000; // 3 seconds
const ACTIVE_SESSION_STORAGE_KEY = 'qrScannerActiveSession';
const COMPLETED_SESSIONS_STORAGE_KEY = 'qrScannerSessions';
const TEMP_SESSION_INDEX_KEY = 'qrScannerTempSessionIndex'; // For tracking in-progress session in history

// GitHub backup constants
const GITHUB_BACKUP_QUEUE_KEY = 'qrScannerBackupQueue';
const GITHUB_BACKUP_CONFIG_KEY = 'qrScannerGithubConfig';
const GITHUB_LAST_BACKUP_KEY = 'qrScannerLastBackup';
const GITHUB_API_URL = 'https://api.github.com';

// Default GitHub backup configuration
let githubBackupConfig = {
    enabled: false,
    token: '', // Never store actual token in localStorage - we'll prompt user
    owner: 'MohammadHamdi11',
    repo: 'QRScanner-webapp',
    path: 'backups',
    branch: 'main',
    autoBackup: true,
    lastBackupTime: null
};

// Queue of sessions waiting to be backed up to GitHub
let backupQueue = [];

// Check if jsQR is already loaded from the local file
document.addEventListener('DOMContentLoaded', function() {
    console.log("DOM fully loaded");
    
    // Load GitHub backup configuration
    loadGitHubBackupConfig();
    
    // Load backup queue
    loadBackupQueue();
    
    loadSessionsFromStorage();
    checkForRecoverableSession();
    updateHistoryView();
    
    // Check if jsQR is already defined (from the script tag in HTML)
    if (typeof jsQR === 'function') {
        console.log("jsQR is already loaded from local file");
        jsQRLoaded = true;
    } else {
        console.log("jsQR not detected, will attempt to load");
        loadJsQR()
        .then(() => console.log("jsQR library loaded and ready"))
        .catch(error => {
            console.error("Error loading jsQR:", error);
            alert("Failed to load QR code scanning library. Please check your files and try again.");
        });
    }
    
    // Add beforeunload event listener to prevent accidental closing during active session
    window.addEventListener('beforeunload', handleBeforeUnload);
    
    // Check for internet connection and process backup queue
    if (navigator.onLine) {
        processBackupQueue();
    }
    
    // Listen for online/offline events
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    // Add GitHub backup settings UI element
    initGitHubBackupUI();
});

// Load jsQR from local file
function loadJsQR() {
    return new Promise((resolve, reject) => {
        // Check if jsQR is already loaded
        if (typeof jsQR === 'function') {
            jsQRLoaded = true;
            resolve(true);
            return;
        }
        
        // Create a new script element to load the local file
        const script = document.createElement('script');
        script.src = 'jsQR.min.js'; // Local file path
        
        // Set event handlers
        script.onload = () => {
            console.log("jsQR loaded successfully from local file");
            jsQRLoaded = true;
            resolve(true);
        };
        script.onerror = (error) => {
            console.error("Failed to load local jsQR:", error);
            reject(error);
        };
        
        // Add the script to the document
        document.head.appendChild(script);
    });
}

// Register Service Worker for PWA functionality
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js')
        .then(registration => {
            console.log('ServiceWorker registration successful with scope: ', registration.scope);
        })
        .catch(err => {
            console.log('ServiceWorker registration failed: ', err);
        });
    });
}

// Online/Offline handlers
function handleOnline() {
    console.log("Internet connection detected");
    updateBackupStatus("Connected - Processing backup queue...");
    
    // Process any pending backups
    processBackupQueue();
}

function handleOffline() {
    console.log("Internet connection lost");
    updateBackupStatus("Offline - Backups queued for later");
}

// Initialize GitHub backup UI
function initGitHubBackupUI() {
    // Create the settings tab if it doesn't exist
    if (!document.getElementById('settings')) {
        // Add settings tab button
        const settingsTab = document.createElement('div');
        settingsTab.className = 'tab';
        settingsTab.setAttribute('data-tab', 'settings');
        settingsTab.textContent = 'Settings';
        document.querySelector('.tabs').appendChild(settingsTab);
        
        // Add settings tab content
        const settingsContent = document.createElement('div');
        settingsContent.className = 'tab-content';
        settingsContent.id = 'settings';
        settingsContent.innerHTML = `
            <h2>GitHub Backup Settings</h2>
            <div class="backup-status-container">
                <div id="backup-status" class="backup-status">
                    <span class="status-indicator ${navigator.onLine ? 'online' : 'offline'}"></span>
                    <span id="backup-status-text">${navigator.onLine ? 'Connected' : 'Offline'}</span>
                </div>
                <div id="last-backup-time">Last backup: Never</div>
            </div>
            <div class="settings-form">
                <div class="form-group">
                    <label for="github-backup-enabled">Enable GitHub Backup</label>
                    <input type="checkbox" id="github-backup-enabled" ${githubBackupConfig.enabled ? 'checked' : ''}>
                </div>
                <div class="form-group">
                    <label for="github-token">GitHub Token (Personal Access Token)</label>
                    <input type="password" id="github-token" placeholder="Enter GitHub token">
                    <small>Your token is never stored in plain text. You'll need to re-enter it when you reopen the app.</small>
                </div>
                <div class="form-group">
                    <label for="github-owner">Repository Owner</label>
                    <input type="text" id="github-owner" value="${githubBackupConfig.owner}">
                </div>
                <div class="form-group">
                    <label for="github-repo">Repository Name</label>
                    <input type="text" id="github-repo" value="${githubBackupConfig.repo}">
                </div>
                <div class="form-group">
                    <label for="github-path">Backup Folder Path</label>
                    <input type="text" id="github-path" value="${githubBackupConfig.path}">
                </div>
                <div class="form-group">
                    <label for="github-branch">Branch</label>
                    <input type="text" id="github-branch" value="${githubBackupConfig.branch}">
                </div>
                <div class="form-group">
                    <label for="github-auto-backup">Auto Backup New Sessions</label>
                    <input type="checkbox" id="github-auto-backup" ${githubBackupConfig.autoBackup ? 'checked' : ''}>
                </div>
                <div class="buttons">
                    <button id="save-github-settings" class="button">Save Settings</button>
                    <button id="test-connection" class="button">Test Connection</button>
                    <button id="force-backup" class="button">Force Backup All</button>
                </div>
                <div id="queue-status">
                    Items in backup queue: ${backupQueue.length}
                </div>
            </div>
        `;
        document.querySelector('.content').appendChild(settingsContent);
        
        // Add CSS for the backup settings
        const style = document.createElement('style');
        style.textContent = `
            .backup-status-container {
                margin-bottom: 20px;
                padding: 10px;
                background-color: #f5f5f5;
                border-radius: 5px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            .backup-status {
                display: flex;
                align-items: center;
            }
            .status-indicator {
                width: 12px;
                height: 12px;
                border-radius: 50%;
                margin-right: 8px;
            }
            .online {
                background-color: #4CAF50;
                box-shadow: 0 0 5px #4CAF50;
            }
            .offline {
                background-color: #F44336;
            }
            .warning {
                background-color: #FFC107;
            }
            .form-group {
                margin-bottom: 15px;
            }
            .form-group label {
                display: block;
                margin-bottom: 5px;
                font-weight: bold;
            }
            .form-group input[type="text"], 
            .form-group input[type="password"] {
                width: 100%;
                padding: 8px;
                border: 1px solid #ddd;
                border-radius: 4px;
            }
            .form-group small {
                color: #666;
                font-size: 0.8em;
            }
            #queue-status {
                margin-top: 15px;
                padding: 10px;
                background-color: #f0f0f0;
                border-radius: 4px;
            }
            .backup-item {
                position: relative;
            }
            .backup-indicator {
                position: absolute;
                top: 5px;
                right: 10px;
                font-size: 0.8em;
                padding: 2px 5px;
                border-radius: 3px;
                color: white;
            }
            .backed-up {
                background-color: #4CAF50;
            }
            .not-backed-up {
                background-color: #F44336;
            }
            .backup-pending {
                background-color: #FFC107;
                color: black;
            }
        `;
        document.head.appendChild(style);
        
        // Add event listeners for the settings
        document.getElementById('save-github-settings').addEventListener('click', saveGitHubSettings);
        document.getElementById('test-connection').addEventListener('click', testGitHubConnection);
        document.getElementById('force-backup').addEventListener('click', forceBackupAll);
        
        // Register the tab click event for the new tab
        document.querySelector('.tab[data-tab="settings"]').addEventListener('click', () => {
            const tabId = 'settings';
            tabs.forEach(t => t.classList.remove('active'));
            tabContents.forEach(tc => tc.classList.remove('active'));
            document.querySelector(`[data-tab="${tabId}"]`).classList.add('active');
            document.getElementById(tabId).classList.add('active');
            
            // Update the queue status when the tab is opened
            document.getElementById('queue-status').textContent = `Items in backup queue: ${backupQueue.length}`;
            updateLastBackupTime();
        });
    }
    
    // Update the last backup time display
    updateLastBackupTime();
}

// Update backup status UI
function updateBackupStatus(message, status = 'info') {
    const statusText = document.getElementById('backup-status-text');
    const statusIndicator = document.querySelector('.status-indicator');
    
    if (statusText && statusIndicator) {
        statusText.textContent = message;
        
        // Update the indicator color based on status
        statusIndicator.className = 'status-indicator';
        if (status === 'error') {
            statusIndicator.classList.add('offline');
        } else if (status === 'warning') {
            statusIndicator.classList.add('warning');
        } else if (status === 'success') {
            statusIndicator.classList.add('online');
        } else {
            // Default to the navigator online status
            statusIndicator.classList.add(navigator.onLine ? 'online' : 'offline');
        }
    }
}

// Update last backup time display
function updateLastBackupTime() {
    const lastBackupElement = document.getElementById('last-backup-time');
    if (lastBackupElement) {
        const lastBackup = localStorage.getItem(GITHUB_LAST_BACKUP_KEY);
        if (lastBackup) {
            const lastBackupDate = new Date(JSON.parse(lastBackup));
            lastBackupElement.textContent = `Last backup: ${formatDateTime(lastBackupDate)}`;
        } else {
            lastBackupElement.textContent = `Last backup: Never`;
        }
    }
}

// Save GitHub settings from the form
function saveGitHubSettings() {
    const enabled = document.getElementById('github-backup-enabled').checked;
    const token = document.getElementById('github-token').value;
    const owner = document.getElementById('github-owner').value;
    const repo = document.getElementById('github-repo').value;
    const path = document.getElementById('github-path').value;
    const branch = document.getElementById('github-branch').value;
    const autoBackup = document.getElementById('github-auto-backup').checked;
    
    // Validate inputs
    if (enabled && (!token || !owner || !repo)) {
        alert('Please fill in all required fields (token, owner, repository)');
        return;
    }
    
    // Update config
    githubBackupConfig.enabled = enabled;
    githubBackupConfig.owner = owner;
    githubBackupConfig.repo = repo;
    githubBackupConfig.path = path || 'backups';
    githubBackupConfig.branch = branch || 'main';
    githubBackupConfig.autoBackup = autoBackup;
    
    // Store the token securely (in memory only, not in localStorage)
    if (token) {
        githubBackupConfig.token = token;
        
        // For security, clear the input field
        document.getElementById('github-token').value = '••••••••';
    }
    
    // Save config (without token) to localStorage
    const safeConfig = { ...githubBackupConfig };
    delete safeConfig.token;  // Never store token in localStorage
    localStorage.setItem(GITHUB_BACKUP_CONFIG_KEY, JSON.stringify(safeConfig));
    
    alert('GitHub backup settings saved!');
    
    // If enabled and we have queued items, try to process them
    if (enabled && backupQueue.length > 0 && navigator.onLine) {
        processBackupQueue();
    }
}

// Test GitHub connection
async function testGitHubConnection() {
    const token = githubBackupConfig.token || document.getElementById('github-token').value;
    const owner = document.getElementById('github-owner').value;
    const repo = document.getElementById('github-repo').value;
    
    if (!token || !owner || !repo) {
        alert('Please fill in all required fields and save settings first');
        return;
    }
    
    updateBackupStatus("Testing connection...", "warning");
    
    try {
        // Test connection by getting repo info
        const response = await fetch(`${GITHUB_API_URL}/repos/${owner}/${repo}`, {
            method: 'GET',
            headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json'
            }
        });
        
        if (response.ok) {
            const repoInfo = await response.json();
            updateBackupStatus(`Connected to ${repoInfo.full_name}`, "success");
            alert('Connection successful! Repository access confirmed.');
        } else {
            const error = await response.json();
            updateBackupStatus(`Connection failed: ${error.message}`, "error");
            alert(`Connection failed: ${error.message}`);
        }
    } catch (error) {
        updateBackupStatus(`Connection error: ${error.message}`, "error");
        alert(`Connection error: ${error.message}`);
    }
}

// Force backup of all sessions
function forceBackupAll() {
    if (!githubBackupConfig.enabled || !githubBackupConfig.token) {
        alert('Please enable backup and provide a GitHub token first');
        return;
    }
    
    if (!navigator.onLine) {
        alert('You are currently offline. Sessions will be backed up once connection is restored.');
        return;
    }
    
    // Clear existing queue
    backupQueue = [];
    
    // Add all sessions to the queue
    sessions.forEach(session => {
        addToBackupQueue(session);
    });
    
    // Update UI
    document.getElementById('queue-status').textContent = `Items in backup queue: ${backupQueue.length}`;
    
    // Start processing queue
    processBackupQueue();
}

// Load GitHub backup configuration from localStorage
function loadGitHubBackupConfig() {
    try {
        const savedConfig = localStorage.getItem(GITHUB_BACKUP_CONFIG_KEY);
        if (savedConfig) {
            const parsedConfig = JSON.parse(savedConfig);
            // Merge with default config, preserving token in memory
            githubBackupConfig = { ...githubBackupConfig, ...parsedConfig };
        }
    } catch (error) {
        console.error("Error loading GitHub backup config:", error);
    }
}

// Load backup queue from localStorage
function loadBackupQueue() {
    try {
        const savedQueue = localStorage.getItem(GITHUB_BACKUP_QUEUE_KEY);
        if (savedQueue) {
            backupQueue = JSON.parse(savedQueue);
            console.log(`Loaded ${backupQueue.length} items in backup queue`);
        }
    } catch (error) {
        console.error("Error loading backup queue:", error);
        backupQueue = [];
    }
}

// Save backup queue to localStorage
function saveBackupQueue() {
    try {
        localStorage.setItem(GITHUB_BACKUP_QUEUE_KEY, JSON.stringify(backupQueue));
    } catch (error) {
        console.error("Error saving backup queue:", error);
    }
}

// Add session to backup queue
function addToBackupQueue(session) {
    // Check if session is already in queue
    const existingIndex = backupQueue.findIndex(item => item.id === session.id);
    
    if (existingIndex === -1) {
        backupQueue.push({
            id: session.id,
            timestamp: new Date().toISOString(),
            retryCount: 0
        });
        
        // Save updated queue
        saveBackupQueue();
        
        console.log(`Added session ${session.id} to backup queue`);
        
        // If we're online and backup is enabled, process queue
        if (navigator.onLine && githubBackupConfig.enabled && githubBackupConfig.token) {
            processBackupQueue();
        }
    }
}

// Process the backup queue
async function processBackupQueue() {
    if (!navigator.onLine || !githubBackupConfig.enabled || !githubBackupConfig.token) {
        return;
    }
    
    if (backupQueue.length === 0) {
        updateBackupStatus("Backup complete - all sessions synced", "success");
        return;
    }
    
    updateBackupStatus(`Processing backup queue (${backupQueue.length} items)...`, "warning");
    
    // Process one item at a time
    const item = backupQueue[0];
    const session = sessions.find(s => s.id === item.id);
    
    if (!session) {
        // Session no longer exists, remove from queue
        backupQueue.shift();
        saveBackupQueue();
        processBackupQueue(); // Continue with next item
        return;
    }
    
    try {
        await backupSessionToGitHub(session);
        
        // Success - remove from queue
        backupQueue.shift();
        saveBackupQueue();
        
        // Update UI
        if (document.getElementById('queue-status')) {
            document.getElementById('queue-status').textContent = `Items in backup queue: ${backupQueue.length}`;
        }
        
        // Process next item if any
        if (backupQueue.length > 0) {
            setTimeout(() => processBackupQueue(), 1000); // Add delay to avoid rate limiting
        } else {
            updateBackupStatus("All backups complete!", "success");
            
            // Update last backup time
            localStorage.setItem(GITHUB_LAST_BACKUP_KEY, JSON.stringify(new Date().toISOString()));
            updateLastBackupTime();
        }
    } catch (error) {
        console.error("Backup failed:", error);
        
        // Increment retry count
        item.retryCount = (item.retryCount || 0) + 1;
        
        if (item.retryCount >= 3) {
            // Too many retries, move to the end of the queue
            backupQueue.shift();
            backupQueue.push(item);
        }
        
        saveBackupQueue();
        updateBackupStatus(`Backup error: ${error.message}`, "error");
        
        // Try again later
        setTimeout(() => processBackupQueue(), 5000);
    }
}

// Backup session to GitHub
async function backupSessionToGitHub(session) {
    if (!session || !githubBackupConfig.token) {
        throw new Error("Invalid session or missing GitHub token");
    }
    
    const { token, owner, repo, path, branch } = githubBackupConfig;
    
    // Create filename
    const fileName = `${session.location.replace(/[^a-z0-9]/gi, '_')}_${formatDateTimeForFile(new Date(session.dateTime))}.json`;
    const filePath = path ? `${path}/${fileName}` : fileName;
    
    // Prepare session data (without sensitive information)
    const sessionData = JSON.stringify(session, null, 2);
    
    try {
        // Check if file already exists
        let sha = null;
        try {
            const checkResponse = await fetch(`${GITHUB_API_URL}/repos/${owner}/${repo}/contents/${filePath}?ref=${branch}`, {
                method: 'GET',
                headers: {
                    'Authorization': `token ${token}`,
                    'Accept': 'application/vnd.github.v3+json'
                }
            });
            
            if (checkResponse.ok) {
                const fileInfo = await checkResponse.json();
                sha = fileInfo.sha;
            }
        } catch (e) {
            // File doesn't exist yet, which is fine
        }
        
        // Create or update file
        const response = await fetch(`${GITHUB_API_URL}/repos/${owner}/${repo}/contents/${filePath}`, {
            method: 'PUT',
            headers: {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message: `Update scan session: ${session.location} (${session.formattedDateTime})`,
                content: btoa(sessionData), // Base64 encode content
                branch: branch,
                sha: sha
            })
        });
        
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.message || "GitHub API error");
        }
        
        console.log(`Successfully backed up session ${session.id} to GitHub`);
        return true;
    } catch (error) {
        console.error("GitHub backup error:", error);
        throw error;
    }
}

// Tab Navigation
tabs.forEach(tab => {
    tab.addEventListener('click', () => {
        const tabId = tab.getAttribute('data-tab');
        tabs.forEach(t => t.classList.remove('active'));
        tabContents.forEach(tc => tc.classList.remove('active'));
        tab.classList.add('active');
        document.getElementById(tabId).classList.add('active');
    });
});

// Start Session Button
startSessionBtn.addEventListener('click', () => {
    // Before showing the modal, verify if jsQR is loaded
    if (!jsQRLoaded) {
        loadJsQR()
        .then(() => {
            sessionModal.style.display = 'block';
            locationInput.focus();
        })
        .catch(() => {
            alert("Failed to load QR scanning library. Please check if jsQR.min.js is in the correct location and refresh the page.");
        });
    } else {
        sessionModal.style.display = 'block';
        locationInput.focus();
    }
});

// Close Modal
closeModalBtn.addEventListener('click', () => {
    sessionModal.style.display = 'none';
});

// Start new scanning session
confirmSessionBtn.addEventListener('click', () => {
    const location = locationInput.value.trim();
    if (!location) {
        alert('Please enter a location');
        return;
    }
    
    // Hide modal
    sessionModal.style.display = 'none';
    
    // Create new session
    const now = new Date();
    const sessionId = `session_${now.getTime()}`;
    const formattedDateTime = formatDateTime(now);
    activeSession = {
        id: sessionId,
        location: location,
        dateTime: now.toISOString(),
        formattedDateTime: formattedDateTime,
        scans: [],
        inProgress: true // Flag to indicate session is in progress
    };
    
    // Add the session to the completed sessions array immediately
    // This ensures it's in history even if app crashes
    sessions.push(activeSession);
    
    // Save the session index for recovery purposes
    localStorage.setItem(TEMP_SESSION_INDEX_KEY, sessions.length - 1);
    
    // Update UI
    currentLocation.textContent = location;
    currentDateTime.textContent = formattedDateTime;
    sessionInfo.style.display = 'block';
    
    // Start camera
    startCamera();
    
    // Clear previous results
    resultBody.innerHTML = '';
    resultTable.style.display = 'none';
    noScansMessage.style.display = 'block';
    
    // Start auto-save interval
    startAutoSave();
    
    // Save all sessions to storage
    saveSessionsToStorage();
    
    // Save the active session separately for recovery
    saveActiveSession();
    
    // Update button
    startSessionBtn.textContent = 'End Session';
    startSessionBtn.removeEventListener('click', startSessionBtnHandler);
    startSessionBtn.addEventListener('click', endSessionHandler);
    
    // Update history view to show the new session
    updateHistoryView();
});

// Start auto-save interval
function startAutoSave() {
    // Clear any existing interval
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
    }
    
    // Set new interval
    autoSaveInterval = setInterval(() => {
        if (activeSession) {
            console.log("Auto-saving session data...");
            // Save to both active session storage and the history
            saveActiveSession();
            saveSessionsToStorage();
            // Update history view to reflect changes
            updateHistoryView();
        }
    }, AUTO_SAVE_DELAY);
}

// Stop auto-save interval
function stopAutoSave() {
    if (autoSaveInterval) {
        clearInterval(autoSaveInterval);
        autoSaveInterval = null;
    }
}

// Improved camera initialization function
async function startCamera() {
    try {
        // Create scanner UI elements
        setupScannerUI();
        
        // Try to get camera access
        const constraints = {
            video: {
                facingMode: 'environment',
                width: { ideal: 1280 },
                height: { ideal: 720 }
            }
        };
        console.log("Requesting camera access with constraints:", constraints);
        videoStream = await navigator.mediaDevices.getUserMedia(constraints);
        console.log("Camera access granted:", videoStream);
        
        // Set up video element
        video.srcObject = videoStream;
        video.setAttribute("playsinline", true);
        video.onloadedmetadata = () => {
            console.log(`Video ready: ${video.videoWidth}x${video.videoHeight}`);
            
            // Set canvas dimensions to match video
            canvasElement.width = video.videoWidth;
            canvasElement.height = video.videoHeight;
            
            // Start video playback
            video.play()
            .then(() => {
                console.log("Video playback started");
                scannerPlaceholder.style.display = 'none';
                video.style.display = 'block';
                
                // Start scanning
                scanning = true;
                requestAnimationFrame(scanQRCode);
                
                // Show scanning indicator
                updateScanStatus('Camera active - looking for QR codes');
            })
            .catch(error => {
                console.error("Video playback failed:", error);
                alert("Failed to start video playback. Please try again.");
            });
        };
    } catch (error) {
        console.error("Camera access error:", error);
        alert(`Failed to access camera: ${error.message}. Please check camera permissions.`);
    }
}
// Set up scanner UI elements
function setupScannerUI() {
// Remove any existing UI elements first
const oldElements = document.querySelectorAll('.scanner-ui');
oldElements.forEach(el => el.remove());
// Add scan frame indicator
const scanFrame = document.createElement('div');
scanFrame.className = 'scanner-ui';
scanFrame.id = 'scan-frame';
scanFrame.style.position = 'absolute';
scanFrame.style.top = '50%';
scanFrame.style.left = '50%';
scanFrame.style.transform = 'translate(-50%, -50%)';
scanFrame.style.width = '200px';
scanFrame.style.height = '200px';
scanFrame.style.border = '2px solid #24325f';
scanFrame.style.borderRadius = '10px';
scanFrame.style.boxShadow = '0 0 0 2000px rgba(0, 0, 0, 0.3)';
scanFrame.style.zIndex = '99';
document.querySelector('.scanner-container').appendChild(scanFrame);
// Add status text
const statusText = document.createElement('div');
statusText.className = 'scanner-ui';
statusText.id = 'scan-status';
statusText.style.position = 'absolute';
statusText.style.bottom = '10px';
statusText.style.left = '50%';
statusText.style.transform = 'translateX(-50%)';
statusText.style.backgroundColor = 'rgba(0,0,0,0.7)';
statusText.style.color = 'white';
statusText.style.padding = '8px 16px';
statusText.style.borderRadius = '20px';
statusText.style.zIndex = '100';
statusText.textContent = 'Starting camera...';
document.querySelector('.scanner-container').appendChild(statusText);
// Add scan log panel
const scanLogPanel = document.createElement('div');
scanLogPanel.className = 'scanner-ui';
scanLogPanel.id = 'scan-log';
scanLogPanel.style.position = 'absolute';
scanLogPanel.style.top = '10px';
scanLogPanel.style.right = '10px';
scanLogPanel.style.width = '250px';
scanLogPanel.style.maxHeight = '150px';
scanLogPanel.style.overflowY = 'auto';
scanLogPanel.style.backgroundColor = 'rgba(0,0,0,0.7)';
scanLogPanel.style.color = 'white';
scanLogPanel.style.padding = '8px';
scanLogPanel.style.borderRadius = '8px';
scanLogPanel.style.fontSize = '14px';
scanLogPanel.style.zIndex = '100';
scanLogPanel.innerHTML = '<div style="text-align: center; font-weight: bold; margin-bottom: 5px;">Scan Log</div>';
document.querySelector('.scanner-container').appendChild(scanLogPanel);
// This is crucial for QR detection to work
canvasElement.className = 'scanner-ui';
canvasElement.style.position = 'absolute';
canvasElement.style.top = '0';
canvasElement.style.left = '0';
canvasElement.style.width = '100%';
canvasElement.style.height = '100%';
canvasElement.style.display = 'none'; 
document.querySelector('.scanner-container').appendChild(canvasElement);
}
// Add a log entry to the scan log
function addScanLogEntry(message, type = 'info') {
const scanLog = document.getElementById('scan-log');
if (scanLog) {
const entry = document.createElement('div');
entry.style.borderBottom = '1px solid rgba(255,255,255,0.2)';
entry.style.padding = '4px 0';
entry.style.fontSize = '12px';
// Color code by type
if (type === 'success') {
entry.style.color = '#4caf50';
} else if (type === 'error') {
entry.style.color = '#f44336';
} else if (type === 'warning') {
entry.style.color = '#ff9800';
}
// Add timestamp
const now = new Date();
const timestamp = `${padZero(now.getHours())}:${padZero(now.getMinutes())}:${padZero(now.getSeconds())}`;
entry.innerHTML = `<small>${timestamp}</small> ${message}`;
scanLog.appendChild(entry);
// Scroll to bottom
scanLog.scrollTop = scanLog.scrollHeight;
// Limit entries to keep performance good
while (scanLog.children.length > 20) {
scanLog.removeChild(scanLog.children[1]); // Keep the header
}
}
}
// Highlight QR code when found
function highlightQR(location) {
const frame = document.getElementById('scan-frame');
if (frame) {
frame.style.borderColor = '#FF3B58';
setTimeout(() => {
frame.style.borderColor = '#24325f';
}, 500);
}
// Add success log entry
addScanLogEntry('QR code successfully detected', 'success');
}
// Update scan status message
function updateScanStatus(message) {
const statusEl = document.getElementById('scan-status');
if (statusEl) {
statusEl.textContent = message;
// Add visual indication of status
if (message.includes('Successfully')) {
statusEl.style.backgroundColor = 'rgba(0, 128, 0, 0.8)';  // Green background for success
// Briefly show success then reset
setTimeout(() => {
statusEl.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
}, 2000);
} else if (message.includes('Error') || message.includes('failed')) {
statusEl.style.backgroundColor = 'rgba(220, 0, 0, 0.8)';  // Red background for errors
} else if (message.includes('Duplicate')) {
statusEl.style.backgroundColor = 'rgba(255, 165, 0, 0.8)';  // Orange for duplicates
} else {
statusEl.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';  // Default color
}
}
}
// Enhanced QR code scanning function with additional debugging
function scanQRCode() {
if (!scanning) return;
if (video.readyState === video.HAVE_ENOUGH_DATA) {
try {
// Draw the video frame to the canvas
canvas.drawImage(video, 0, 0, canvasElement.width, canvasElement.height);
// Get image data from the canvas
const imageData = canvas.getImageData(0, 0, canvasElement.width, canvasElement.height);
// Check if we have valid image data
if (imageData.data.length === 0 || imageData.width === 0 || imageData.height === 0) {
console.error("Invalid image data");
updateScanStatus('Error: Invalid image data');
requestAnimationFrame(scanQRCode);
return;
}
// Verify jsQR is available with additional logging
if (typeof jsQR !== 'function') {
console.error("jsQR is not available. Current value:", jsQR);
updateScanStatus('QR scanner not loaded correctly');
// Try to reload the library
loadJsQR().catch(err => console.error("Failed to reload jsQR:", err));
requestAnimationFrame(scanQRCode);
return;
}
// Process with jsQR with try-catch for better error reporting
try {
const code = jsQR(imageData.data, imageData.width, imageData.height, {
inversionAttempts: "dontInvert"
});
if (code && code.data) {
// Make sure we have actual data before proceeding
if (code.data.trim() === '') {
// Empty QR code data, continue scanning
updateScanStatus('Empty QR code detected. Please scan again.');
} else {
console.log("QR Code detected:", code.data);
updateScanStatus(`✅ Successfully scanned: ${code.data.substring(0, 20)}${code.data.length > 20 ? '...' : ''}`);
// Highlight the QR code
highlightQR(code.location);
// Check if this code was recently scanned
if (!lastScannedCodes.has(code.data)) {
// Add to recent scans set and set timeout to remove
lastScannedCodes.add(code.data);
setTimeout(() => {
lastScannedCodes.delete(code.data);
}, 3000); // Prevent duplicate scans for 3 seconds
// Process the scanned code
processScannedCode(code.data);
// Play success sound
playSuccessSound();
} else {
// Duplicate scan
updateScanStatus(`Duplicate scan: ${code.data.substring(0, 20)}${code.data.length > 20 ? '...' : ''}`);
}
}
} else {
// No QR code found in this frame
updateScanStatus('Scanning... Position QR code in the frame');
}
} catch (qrError) {
console.error("jsQR processing error:", qrError);
updateScanStatus('QR processing error: ' + qrError.message);
}
} catch (error) {
console.error("Error in scan process:", error);
updateScanStatus('Error in scan process: ' + error.message);
}
} else {
updateScanStatus('Waiting for camera...');
}
// Continue scanning
requestAnimationFrame(scanQRCode);
}
// Process scanned QR code 
function processScannedCode(data) {
// Additional validation to ensure we're not adding empty codes
if (!data || data.trim() === '') {
console.error("Attempted to process empty QR code data");
updateScanStatus('Error: Empty QR code data');
addScanLogEntry('Empty QR code data - not saved', 'error');
return;
}
const now = new Date();
const scan = {
id: activeSession.scans.length + 1,
content: data,
time: now.toISOString(),
formattedTime: formatTime(now)
};
// Add to active session
activeSession.scans.push(scan);
// Update UI
if (activeSession.scans.length === 1) {
noScansMessage.style.display = 'none';
resultTable.style.display = 'table';
}
const row = document.createElement('tr');
row.innerHTML = `
<td>${scan.id}</td>
<td>${escapeHtml(scan.content)}</td>
<td>${scan.formattedTime}</td>
`;
resultBody.appendChild(row);
// Find the session in the sessions array and update it
const sessionIndex = sessions.findIndex(s => s.id === activeSession.id);
if (sessionIndex !== -1) {
sessions[sessionIndex] = {...activeSession};
}
// Save both active session and completed sessions
saveActiveSession();
saveSessionsToStorage();
// Add to scan log
addScanLogEntry(`Saved: ${data.substring(0, 15)}${data.length > 15 ? '...' : ''}`, 'success');
}
// End current scanning session
function endSessionHandler() {
if (scanning) {
scanning = false;
// Stop auto-save
stopAutoSave();
// Stop camera
if (videoStream) {
videoStream.getTracks().forEach(track => track.stop());
videoStream = null;
}
// Update UI
video.style.display = 'none';
scannerPlaceholder.style.display = 'block';
// Clean up UI elements
const scannerUI = document.querySelectorAll('.scanner-ui');
scannerUI.forEach(el => el.remove());
// Update session status in the array
const sessionIndex = sessions.findIndex(s => s.id === activeSession.id);
if (sessionIndex !== -1) {
// Update the session to mark it as completed
sessions[sessionIndex].inProgress = false;
// Save to storage
saveSessionsToStorage();
// Update history view
updateHistoryView();
// Auto-export this session
exportSession(sessions[sessionIndex]);
}
// Clear the active session storage
clearActiveSession();
// Clear the temp session index
localStorage.removeItem(TEMP_SESSION_INDEX_KEY);
// Reset UI
sessionInfo.style.display = 'none';
startSessionBtn.textContent = 'Start Scanning Session';
startSessionBtn.removeEventListener('click', endSessionHandler);
startSessionBtn.addEventListener('click', startSessionBtnHandler);
// Show confirmation
alert('Session completed and exported successfully!');
// Reset active session
activeSession = null;
}
}
// Handler for start session button
function startSessionBtnHandler() {
// Check if jsQR is loaded
if (!jsQRLoaded) {
loadJsQR()
.then(() => {
sessionModal.style.display = 'block';
locationInput.focus();
})
.catch(() => {
alert("Failed to load QR scanning library. Please check if jsQR.min.js is in the correct location and refresh the page.");
});
} else {
sessionModal.style.display = 'block';
locationInput.focus();
}
}
// Export all history to Excel
exportAllBtn.addEventListener('click', () => {
if (sessions.length === 0) {
alert('No sessions to export');
return;
}
try {
// Add a delay to prevent rapid multiple clicks
exportAllBtn.disabled = true;
// Execute the export
exportAllSessions();
// Re-enable the button after 2 seconds
setTimeout(() => {
exportAllBtn.disabled = false;
}, 2000);
console.log("Export all completed successfully");
} catch (error) {
console.error("Export failed:", error);
alert("Export failed: " + error.message);
exportAllBtn.disabled = false;
}
});
// Sort history sessions
sortBy.addEventListener('change', updateHistoryView);
// Export single session
exportSessionBtn.addEventListener('click', () => {
if (!activeSessionId) return;
const session = sessions.find(s => s.id === activeSessionId);
if (session) {
exportSession(session);
}
});
// Close session details
closeDetailsBtn.addEventListener('click', () => {
sessionDetails.style.display = 'none';
});
// Save active session to local storage
function saveActiveSession() {
if (activeSession) {
try {
localStorage.setItem(ACTIVE_SESSION_STORAGE_KEY, JSON.stringify(activeSession));
console.log("Active session saved", activeSession.id, activeSession.scans.length, "scans");
} catch (error) {
console.error("Error saving active session:", error);
}
}
}
// Clear active session from local storage
function clearActiveSession() {
try {
localStorage.removeItem(ACTIVE_SESSION_STORAGE_KEY);
} catch (error) {
console.error("Error clearing active session:", error);
}
}
// Check if there's a recoverable session
function checkForRecoverableSession() {
try {
// First check for active session
const savedActiveSession = localStorage.getItem(ACTIVE_SESSION_STORAGE_KEY);
const tempSessionIndex = localStorage.getItem(TEMP_SESSION_INDEX_KEY);
if (savedActiveSession) {
const parsedSession = JSON.parse(savedActiveSession);
if (parsedSession && parsedSession.id && parsedSession.scans && parsedSession.scans.length > 0) {
const result = confirm(`Found an incomplete scanning session at ${parsedSession.location} with ${parsedSession.scans.length} scans. Would you like to recover it?`);
if (result) {
// Recover the session
recoverSession(parsedSession);
} else {
// Mark the session as completed in history if it exists there
const sessionIndex = sessions.findIndex(s => s.id === parsedSession.id);
if (sessionIndex !== -1) {
sessions[sessionIndex].inProgress = false;
saveSessionsToStorage();
}
// Clear the session
clearActiveSession();
localStorage.removeItem(TEMP_SESSION_INDEX_KEY);
}
return; // Don't proceed to next check if we've handled this one
}
}
// If no active session, check if there's a session in progress in history
if (tempSessionIndex !== null) {
const index = parseInt(tempSessionIndex);
if (!isNaN(index) && index >= 0 && index < sessions.length) {
const tempSession = sessions[index];
if (tempSession && tempSession.inProgress) {
const result = confirm(`Found an incomplete scanning session at ${tempSession.location} with ${tempSession.scans.length} scans in history. Would you like to recover it?`);
if (result) {
// Recover the session from history
recoverSession(tempSession);
} else {
// Mark as completed
sessions[index].inProgress = false;
saveSessionsToStorage();
localStorage.removeItem(TEMP_SESSION_INDEX_KEY);
}
}
} else {
// Invalid index, clear it
localStorage.removeItem(TEMP_SESSION_INDEX_KEY);
}
}
} catch (error) {
console.error("Error checking for recoverable session:", error);
// Clear potentially corrupted data
clearActiveSession();
localStorage.removeItem(TEMP_SESSION_INDEX_KEY);
}
}
// Recover active session 
function recoverSession(session) {
activeSession = session;
// Make sure the session has inProgress flag set
activeSession.inProgress = true;
// Update UI
currentLocation.textContent = session.location;
currentDateTime.textContent = session.formattedDateTime;
sessionInfo.style.display = 'block';
// Update scan table
resultBody.innerHTML = '';
if (session.scans.length > 0) {
noScansMessage.style.display = 'none';
resultTable.style.display = 'table';
session.scans.forEach(scan => {
const row = document.createElement('tr');
row.innerHTML = `
<td>${scan.id}</td>
<td>${escapeHtml(scan.content)}</td>
<td>${scan.formattedTime}</td>
`;
resultBody.appendChild(row);
});
} else {
noScansMessage.style.display = 'block';
resultTable.style.display = 'none';
}
// Check if session exists in the sessions array
const sessionIndex = sessions.findIndex(s => s.id === session.id);
if (sessionIndex === -1) {
// Session doesn't exist in sessions array, add it
sessions.push(session);
} else {
// Update existing session
sessions[sessionIndex] = {...session};
}
// Save to storage
saveSessionsToStorage();
saveActiveSession();
// Store the session index for recovery
const index = sessions.findIndex(s => s.id === session.id);
if (index !== -1) {
localStorage.setItem(TEMP_SESSION_INDEX_KEY, index);
}
// Switch to scanner tab
tabs.forEach(t => t.classList.remove('active'));
tabContents.forEach(tc => tc.classList.remove('active'));
document.querySelector('[data-tab="scanner"]').classList.add('active');
document.getElementById('scanner').classList.add('active');
// Update button
startSessionBtn.textContent = 'End Session';
startSessionBtn.removeEventListener('click', startSessionBtnHandler);
startSessionBtn.addEventListener('click', endSessionHandler);
// Start camera
startCamera();
// Start auto-save
startAutoSave();
}
// Save completed sessions to local storage
function saveSessionsToStorage() {
try {
localStorage.setItem(COMPLETED_SESSIONS_STORAGE_KEY, JSON.stringify(sessions));
console.log("Completed sessions saved:", sessions.length);
} catch (error) {
console.error("Error saving completed sessions:", error);
alert("Failed to save sessions. Your device might be low on storage space.");
}
}
// Load sessions from local storage
function loadSessionsFromStorage() {
try {
const savedSessions = localStorage.getItem(COMPLETED_SESSIONS_STORAGE_KEY);
if (savedSessions) {
sessions = JSON.parse(savedSessions);
console.log("Loaded", sessions.length, "completed sessions");
}
} catch (error) {
console.error("Error loading sessions:", error);
sessions = [];
}
}
// Warn user before closing the page during active session
function handleBeforeUnload(event) {
if (activeSession) {
// Save one last time
saveActiveSession();
saveSessionsToStorage();
// Show confirmation dialog
const message = "You have an active scanning session. Are you sure you want to leave?";
event.returnValue = message;
return message;
}
}
// Update history view with sessions
function updateHistoryView() {
if (sessions.length === 0) {
historyList.innerHTML = '<p class="no-results">No scanning sessions found.</p>';
return;
}
// Sort sessions based on selected option
const sortValue = sortBy.value;
const sortedSessions = [...sessions].sort((a, b) => {
if (sortValue === 'date-desc') {
return new Date(b.dateTime) - new Date(a.dateTime);
} else if (sortValue === 'date-asc') {
return new Date(a.dateTime) - new Date(b.dateTime);
} else if (sortValue === 'location') {
return a.location.localeCompare(b.location);
}
return 0;
});
// Generate HTML
historyList.innerHTML = '';
sortedSessions.forEach(session => {
const card = document.createElement('div');
card.className = 'card history-item';
card.setAttribute('data-id', session.id);
// Add class to indicate in-progress sessions
if (session.inProgress) {
card.classList.add('in-progress');
card.style.borderLeft = '4px solid #FF3B58';
}
card.innerHTML = `
<div class="flex-between">
<div>
<h3>${escapeHtml(session.location)}${session.inProgress ? ' <span style="color:#FF3B58">(In Progress)</span>' : ''}</h3>
<p>${session.formattedDateTime}</p>
</div>
<div>
<p><strong>${session.scans.length}</strong> scans</p>
</div>
</div>
`;
card.addEventListener('click', () => {
activeSessionId = session.id;
showSessionDetails(session);
});
historyList.appendChild(card);
});
}
// Show session details
function showSessionDetails(session) {
detailLocation.textContent = session.location;
detailDateTime.textContent = session.formattedDateTime;
detailCount.textContent = session.scans.length;
// Show in-progress status if applicable
const statusElement = document.querySelector('#sessionDetails h3');
if (statusElement) {
if (session.inProgress) {
statusElement.innerHTML = `Session Details <span style="color:#FF3B58">(In Progress)</span>`;
// Add recover button if the session is in progress and not currently active
if (!activeSession || activeSession.id !== session.id) {
const recoverButton = document.createElement('button');
recoverButton.className = 'button';
recoverButton.style.backgroundColor = '#FF3B58';
recoverButton.textContent = 'Resume Session';
recoverButton.addEventListener('click', () => {
recoverSession(session);
sessionDetails.style.display = 'none';  // Hide details after recovering
});
// Insert before export button
const buttonsDiv = document.querySelector('#sessionDetails .buttons');
if (buttonsDiv && buttonsDiv.firstChild) {
buttonsDiv.insertBefore(recoverButton, buttonsDiv.firstChild);
}
}
} else {
statusElement.textContent = 'Session Details';
// Remove recover button if it exists
const recoverButton = document.querySelector('#sessionDetails button[style*="FF3B58"]');
if (recoverButton) {
recoverButton.remove();
}
}
}
// Fill table
detailsBody.innerHTML = '';
session.scans.forEach(scan => {
const row = document.createElement('tr');
row.innerHTML = `
<td>${scan.id}</td>
<td>${escapeHtml(scan.content)}</td>
<td>${scan.formattedTime}</td>
`;
detailsBody.appendChild(row);
});
sessionDetails.style.display = 'block';
}
// Export single session to Excel
function exportSession(session) {
if (!window.XLSX) {
console.error("XLSX library not loaded");
alert("Export functionality is not available. Please check your internet connection.");
return;
}
const fileName = `${session.location.replace(/[^a-z0-9]/gi, '_')}_${formatDateTimeForFile(new Date(session.dateTime))}.xlsx`;
// Prepare data 
const data = [
['Number', 'Student ID', 'Location', 'Date', 'Time']
];
session.scans.forEach(scan => {
const scanDate = new Date(scan.time);
data.push([
scan.id,                // Row number (previously ID)
scan.content,           // QR code content is now Student ID
session.location,
formatDate(scanDate),
formatTime(scanDate)
]);
});
// Create workbook
const ws = XLSX.utils.aoa_to_sheet(data);
const wb = XLSX.utils.book_new();
XLSX.utils.book_append_sheet(wb, ws, "Scans");
// Save file
XLSX.writeFile(wb, fileName);
}
// Export all sessions to Excel
function exportAllSessions() {
if (sessions.length === 0) return;
if (!window.XLSX) {
console.error("XLSX library not loaded");
alert("Export functionality is not available. Please check your internet connection.");
return;
}
const fileName = `QR_Scan_All_Sessions_${formatDateTimeForFile(new Date())}.xlsx`;
const wb = XLSX.utils.book_new();
// Counter for unique sheet names
let sheetCounter = {};
// For each session
sessions.forEach(session => {
const data = [
['Number', 'Student ID', 'Location', 'Date', 'Time']
];
session.scans.forEach(scan => {
const scanDate = new Date(scan.time);
data.push([
scan.id,
scan.content,
session.location,
formatDate(scanDate),
formatTime(scanDate)
]);
});
if (data.length > 1) {
const ws = XLSX.utils.aoa_to_sheet(data);
// Create unique sheet name
let baseSheetName = session.location.substring(0, 25).replace(/[^a-z0-9]/gi, '_');
if (baseSheetName.length === 0) baseSheetName = "Session";
// Ensure uniqueness
if (sheetCounter[baseSheetName]) {
sheetCounter[baseSheetName]++;
baseSheetName = baseSheetName + "_" + sheetCounter[baseSheetName];
} else {
sheetCounter[baseSheetName] = 1;
}
// Excel sheet names cannot exceed 31 characters
const sheetName = baseSheetName.substring(0, 31);
try {
XLSX.utils.book_append_sheet(wb, ws, sheetName);
} catch (e) {
console.error("Error adding sheet:", e);
// If there's an error with this sheet, try with a generic name
XLSX.utils.book_append_sheet(wb, ws, "Session_" + Math.random().toString(36).substring(2, 7));
}
}
});
try {
// Save file with error handling
XLSX.writeFile(wb, fileName);
console.log("File written successfully:", fileName);
} catch (e) {
console.error("Error writing file:", e);
alert("Error exporting file: " + e.message);
}
}
// Add placeholder for success sound function
function playSuccessSound() {
// Sound functionality could be added here
// For now, we just have a placeholder to avoid errors
}
// Helper function to format date for display
function formatDate(date) {
return `${date.getFullYear()}-${padZero(date.getMonth() + 1)}-${padZero(date.getDate())}`;
}
// Helper function to format time for display
function formatTime(date) {
return `${padZero(date.getHours())}:${padZero(date.getMinutes())}:${padZero(date.getSeconds())}`;
}
// Helper function to format date and time for display
function formatDateTime(date) {
return `${formatDate(date)} ${formatTime(date)}`;
}
// Helper function to format date and time for filenames
function formatDateTimeForFile(date) {
return `${date.getFullYear()}${padZero(date.getMonth() + 1)}${padZero(date.getDate())}_${padZero(date.getHours())}${padZero(date.getMinutes())}`;
}
// Helper function to pad with leading zero
function padZero(num) {
return num.toString().padStart(2, '0');
}
// Helper function to escape HTML to prevent XSS
function escapeHtml(text) {
if (!text) return '';
return text
.toString()
.replace(/&/g, "&amp;")
.replace(/</g, "&lt;")
.replace(/>/g, "&gt;")
.replace(/"/g, "&quot;")
.replace(/'/g, "&#039;");
}
// Initialize button event handler
startSessionBtn.addEventListener('click', startSessionBtnHandler);
// When window loads, check if we need to request permissions
window.addEventListener('load', () => {
// We request camera permission only when the user starts a session
// instead of on page load for better user experience
// Modern browsers don't allow creating directories or choosing save locations
// for security reasons, but files will be saved according to browser's download settings
});
</script>
</body>
</html>
